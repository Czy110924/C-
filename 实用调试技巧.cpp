//#define _CRT_SECURE_NO_WARNINGS 1
//#include <stdio.h>
//
//
//
//
//
//int main()
//{
//	//bug就是臭虫，死了的臭虫
//	//Debug调试版本，程序员调试的版本     Release发布版本，测试员测试的版本
//
//	//F5使用：跳到断点调试，前面快速执行完，F9设置取消断点
//	//F10逐过程，处理一个过程，也就是一个语句或一次函数调用
//	//F11逐语句，每次执行一条语句，可以使我们的执行逻辑进入函数内部
//	//Ctrl+F5不调试
//
//	//调试 -> 窗口
//	//断点可以查看断点设置，也可以用于取消断点
//	//条件断点，右击断点设置条件比如i==500可以查看第500次循环
//	// 
//	//监视可以查看变量或数组
//	//内存可以通过地址查看变量或数组，寄存器数值
//	//反汇编可查看代码翻译的汇编代码
//	//寄存器可以查看寄存器里面的数值，数值不断变化
//	//调用堆栈可以查看函数的调用逻辑
//
//	//多多练习  熟能生巧
//
//
//	//栈区内存使用习惯是：先使用高地址空间，在使用低地址空间
//	//数组随着下标增长，地址由低到高变化
//	//若先定义变量，再定义数组，越界访问可能访问到变量，
//	//并且越界访问可以修改成功，但会报错
//
//
//
//
//
//	//预防发生错误，减少bug可能性，写出易于调试的代码
//	
//	
//
//
//	int arr[10] = { 0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz; i++)
//	{
//		arr[i] = i + 1;
//	}
//	return 0;
//}
//
////以下就是顶级代码，牛逼代码，喵喵喵
//void strcpy_my(char* dest, char* str)
//{
//	while (*dest++ = *str++)//巧妙运用\0就是0的情况，
//							//返回false终止循环，还把\0拷贝过去了
//	{
//		;
//	}
//}